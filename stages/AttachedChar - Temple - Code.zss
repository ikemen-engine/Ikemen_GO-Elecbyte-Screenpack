#ZSS language: https://github.com/ikemen-engine/Ikemen-GO/wiki/ZSS
#ZSS syntax highlighter for Notepad++: https://github.com/ikemen-engine/zss_npp
#-------------------------------------------------------------------------------
#Commenting in ZSS
#You may notice that the ";" character is now replaced with the "#" character.
#This is because ";" is now used to separate parameters in sctrls rather than a
#blank space.

#;=========================================================================================
#Attached Char Player states
#;=========================================================================================
#;First we override this state from the common files to avoid 
#debug warnings due to remappal
[StateDef 5900;
anim:-2;]
ignorehitpause if 1
{changestate{value:0;}}
#=========================================================================================
[Statedef 0;
anim:-2;]
#=========================================================================================
#We override this state from the common files to avoid debug warnings when the fight is over
[Statedef 175;
anim: -2;]
#=========================================================================================
#Helper Pillar state
#===============================================================================
#Helper Pillar - basic state
[StateDef 200; 
type:S;
movetype:I;
physics:N;
ctrl:0;
anim:-2;
velset:0,0;]

#Now we'll define some aspects for the helper
assertSpecial{flag:nohardcodedkeys;flag2:noautoturn;}
playerpush{value: 0;}
nothitby{value: SCA;}

#The left pillar has an anim with a CLSN, there is a reason for this
if Pos X < 0 {Changeanim{value:599}}

#These two define the right pillar collision size
Map(WidthDetect):=30 * StageVar(StageInfo.XScale);
Map(HeightDetect):=180 * StageVar(StageInfo.YScale);
AngleDraw{scale:StageVar(StageInfo.XScale),StageVar(StageInfo.YScale);}
TransformCLSN{scale:StageVar(StageInfo.XScale),StageVar(StageInfo.YScale);}

if Map(BrokenObject) = 0# objects should only be broken once
&& Roundstate > 1# objects should only be broken once the fight started
{
 #We'll run a loop to check if the player 
 #is airborne AND is in a gethit state; 
 for i = 1 ; 8
 {
  if Player($i),HitFall = 1
  && Player($i),StateType = A
  && Player($i),Pos Y != 0
  && Player($i),SprPriority > -9 #This is to avoid being affected when a stage fatal is triggered
  && #Now let's check if the player is near the object
    (
      #One way to detect is via Player Position
      (Pos X > 0 &&
      Abs((Player($i),Pos X+Player($i),Vel X - Pos X)) < Map(WidthDetect)
      && Abs((Player($i),Pos Y+Player($i),Vel Y - Pos Y)) < Map(HeightDetect))
      
      ||
      
      #Another option is to check via CLSNOverlap
      (Pos X < 0 &&
      CLSNOverLap(CLSN2,Player($i),ID,CLSN2))
    )
  {
   #This will define the object as "broken" 
   Map(BrokenObject):= 1;

   playSnd{value: 0,1;}

   #For the left side pillar
   if Pos X < 0 {
   #We expand the stage via ModifyStageVar
   ModifyStageVar{camera.boundleft:-150;}
   #We hide the fire from the pillars via ModifyBGCtrl and a BGCtrl "Enable"
   ModifyBGCtrl{ID:301;value:0;}
   #We hide the pillars themselves via ModifyStageBG and changing the anim
   #which ends in an invisible frame! Alternative: shrink it via scalestart
   ModifyStageBG{ID:101;actionno:1;}
   }
   
   #For the right side pillar
   if Pos X > 0 {
   ModifyStageVar{camera.boundright:150;}
   ModifyBGCtrl{ID:302;value:0;}
   ModifyStageBG{ID:102;actionno:1;}
   }
   
   #Let's throw some debris
   for j = 1 ; RandomRange(30,40)
    {Explod{
    ID: $j;
    anim:600+RandomRange(0,40);
    sprpriority:9;
    space:stage;
    pos:facing*30,-Map(HeightDetect)/2;
	  Vel:RandomRange(-4,4),RandomRange(-7,-3);
    accel:0,0.3;
    bindtime:1;
    bindid:ID;
	  removetime:120;
	  ownpal:1;
    scale:1,1;
	palfx.time: -1;
	palfx.add:-32,-96,32;
    angle:randomrange(1,360);
	  random:Map(WidthDetect)/2,Map(HeightDetect)/2;}
    }
  }
 }
}

#We don't want the debris going under the floor but bouncing on it.
for t = 1; NumExplod
{
 if ExplodVar($t, 0, Pos Y)+ExplodVar($t, 0, Vel Y) >= 0 
 && ExplodVar($t, 0, Vel Y) > 0.2
  {
    ModifyExplod{ID:$t;Vel: ExplodVar($t, 0, Vel X)*0.8,ExplodVar($t, 0, Vel Y)*-0.5;}
  }
}

#For the "slowdown" effect
if Map(BrokenObject) = 1 && 
Map(SlowDownTime) > 0 
{
 pause{time:1}
 Map(SlowDownTime):=Map(SlowDownTime)-1;
}

#Resetting the objects on load,
#but condition it to ResetBG!
if RoundState = 0 
&& StageVar(StageInfo.ResetBG) = 1
{
 Map(SlowDownTime):= StageConst(SlowDown);

 Map(BrokenObject):= 0;
 if Pos X < 0 {
    #We shrink the stage via ModifyStageVar
    ModifyStageVar{camera.boundleft:-50;}
    #We show the fire from the pillars via ModifyBGCtrl and a BGCtrl "Enable"
    ModifyBGCtrl{ID:301;value:1;}
    #We show the pillars themselves via ModifyStageBG and Changeanim = 0
    ModifyStageBG{ID:101;actionno:0;}
   }
 
 if Pos X > 0 {
   ModifyStageVar{camera.boundright:50;}
   ModifyBGCtrl{ID:302;value:1;}
   ModifyStageBG{ID:102;actionno:0;}
   }
}
#;=========================================================================================
#Negative states
#===============================================================================
[Statedef -4]
#Attached chars will often use helpers to interact with Teams 1 and 2.

#Stage Fatal! If the player dies within the window and is thrown up high enough, player will go through
#and "fall" across, then an envhsake and a sound will play.
if IsHelper(1) {#let's run this only once
 DisplayToClipboard{text:"%v";params:Map(PlayerNumberIsDead);}
 if RoundState = 3 && 
 (
  (Player(1),DecisiveRound && Player(1),Win = 1) ||
  (Player(2),DecisiveRound && Player(2),Win = 1) ||
  (Player(1),TeamMode = Turns && Player(1),Win = 0) || 
  (Player(2),TeamMode = Turns && Player(2),Win = 0)
 )
 && Map(PlayerNumberIsDead) = 0
 {
 for i = 1 ; 8
  {
   if Player($i),Alive = 0 && Player($i),Vel Y != 0
   && Abs(Player($i),Pos X + CameraPos X) < 30
   && Player($i),Pos Y < -25
   && Player($i),Pos Y > -150
   {
    #Mark the Player for the Fatal, play the sound and pause
	Map(PlayerNumberIsDead):=Player($i),ID;
	playSnd{value: 0,2;}
	pause{time:120}
   }
  }
 }#End Only in Roundover and conditions
  if Map(PlayerNumberIsDead) != 0
  #If the stage fatal is triggered,
  #hide the lifebars, send the defeated player behind most stage layers,
  #hide their reflection and shadow, and have them "fall" under the ground level,
  #and trigger an EnvShake when they landed.
  {
    assertSpecial{flag:nobardisplay;}
	SprPriority{value:-9;layerno:-1;RedirectId:Map(PlayerNumberIsDead);}
    ModifyReflection{intensity:0;RedirectId:Map(PlayerNumberIsDead);}
	ModifyShadow{intensity:0;RedirectId:Map(PlayerNumberIsDead);}
	GroundLevelOffset{value:900;RedirectId:Map(PlayerNumberIsDead);}
	if PlayerID(Map(PlayerNumberIsDead)),Pos Y + Vel Y >= 0
	&& PlayerID(Map(PlayerNumberIsDead)),Vel Y > 5
		{envShake{time:10;freq:10;ampl:10;}}
  }
}#End IsHelper(1)

if IsHelper(1) && RoundState = 0#Reset the fatal just in case
{
 Map(PlayerNumberIsDead):= 0;
}

#Note the 'StageBackEdgeDist' and 'StageFrontEdgeDist' triggers,
#they are useful for Attached Chars!
if NumHelper(1) = 0
{Helper{helpertype:normal;
   facing:1;
   name:"Left_Pillar";
   pos: -StageBackEdgeDist,10;
   ID: 1;
   stateno :200;
   keyctrl : 0;
   supermovetime:0;
   pausemovetime:0;
   size.ground.back:1;
   size.ground.front:1;
   size.height:1;
   preserve:1;#This is relevant in Attached Char helpers!
   standby:0;#This is relevant in Attached Char helpers!
   immortal:1;
   ownpal:1;}
}
if NumHelper(2) = 0
{Helper{helpertype:normal;
   facing:-1;
   name:"Right_Pillar";
   pos: StageFrontEdgeDist,10;
   ID: 2;
   stateno :200;
   keyctrl : 0;
   supermovetime:0;
   pausemovetime:0;
   size.ground.back:1;
   size.ground.front:1;
   size.height:1;
   preserve:1;
   standby:0;
   immortal:1;
   ownpal:1;}
}  

#Now we'll define some conditions for the
#Attached Character itself, which is not used anymore.
if IsHelper = 0
{
 assertSpecial{flag:nohardcodedkeys;flag2:noautoturn;}
 tagout{}
}