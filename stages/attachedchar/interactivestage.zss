#ZSS language: https://github.com/ikemen-engine/Ikemen-GO/wiki/ZSS
#ZSS syntax highlighter for Notepad++: https://github.com/ikemen-engine/zss_npp
#-------------------------------------------------------------------------------
#Commenting in ZSS
#You may notice that the ";" character is now replaced with the "#" character.
#This is because ";" is now used to separate parameters in sctrls rather than a
#blank space.

#;=========================================================================================
#Attached Char player states
#;=========================================================================================
#;First we override this state from the common files to avoid 
#debug warnings due to remappal
[StateDef 5900;
anim:-2;]
ignorehitpause if 1
{changestate{value:0;}}
#=========================================================================================
[Statedef 0;
anim:-2;]
#=========================================================================================
#We override this state from the common files to avoid debug warnings when the fight is over
[Statedef 175;
anim: -2;]
#=========================================================================================
#Helper Pillar state
#===============================================================================
#Helper Pillar - basic state
[StateDef 200; 
type:S;
movetype:I;
physics:N;
ctrl:0;
anim:-2;
velset:0,0;]

#Now we'll define some aspects for the helper
assertSpecial{flag:nohardcodedkeys;flag2:noautoturn;}
playerPush{value: 0;}
notHitBy{value: SCA;}

#The left pillar has an anim with a CLSN, there is a reason for this
if pos X < 0 {Changeanim{value:599}}

#These two define the right pillar collision size
Map(WidthDetect):=30 * stageVar(StageInfo.XScale);
Map(HeightDetect):=180 * stageVar(StageInfo.YScale);
angleDraw{scale:stageVar(stageInfo.xScale),stageVar(stageInfo.yScale);}
transformClsn{scale:stageVar(stageInfo.xScale),stageVar(stageInfo.yScale);}

if Map(BrokenObject) = 0# objects should only be broken once
&& roundState > 1# objects should only be broken once the fight started
{
 #We'll run a loop to check if the player 
 #is airborne AND is in a gethit state; 
 for i = 1 ; 8
 {
  if player($i),hitFall = 1
  && player($i),stateType = A
  && player($i),pos y != 0
  && player($i),sprPriority > -9 #This is to avoid being affected when a stage fatal is triggered
  && #Now let's check if the player is near the object
    (
      #One way to detect is via player Position
      (pos X > 0 &&
      abs((player($i),pos x+player($i),vel x - pos x)) < Map(WidthDetect)
      && abs((player($i),pos y+player($i),vel y - pos y)) < Map(HeightDetect))
      
      ||
      
      #Another option is to check via clsnOverLap
      (pos x < 0 &&
      clsnOverLap(clsn2,player($i),ID,clsn2))
    )
  {
   #This will define the object as "broken" 
   Map(BrokenObject):= 1;

   playSnd{value: 0,1;pan:pos x*facing;}

   #For the left side pillar
   if pos x < 0 {

   #We expand the stage via modifyStageVar
   modifyStageVar{camera.boundleft:-200;}
   #We hide the reflection from the pillars via modifyBGCtrl and a BGCtrl "Enable"
   modifyBGCtrl{ID:301;value:0;}
   #We hide the pillars themselves via modifyStageBG and changing the anim
   #which ends in an invisible frame! Alternative: shrink it via scalestart
   modifyStageBG{ID:101;actionno:1;}
   }
   
   #For the right side pillar
   if pos x > 0 {
   modifyStageVar{camera.boundright:200;}
   modifyBGCtrl{ID:302;value:0;}
   modifyStageBG{ID:102;actionno:1;}
   }
   
   #Let's throw some debris
   for j = 1 ; randomRange(30,40)
    {explod{
    ID: $j;
    anim:600+randomRange(0,5);
    sprpriority:9;
    space:stage;
    pos:facing*30,-Map(HeightDetect)/2;
	Vel:randomRange(-4,4),randomRange(-7,-3);
    accel:0,0.3;
    bindtime:1;
    bindid:ID;
	removetime:120;
	ownpal:1;
    scale:1,1;
	trans:addalpha;
	alpha:128,128;
    angle:randomrange(1,360);
	random:Map(WidthDetect)/2,Map(HeightDetect)/2;}
    }
  }
 }
}

#We don't want the debris going under the floor, but bouncing on it.
if NumExplod > 0
{for t = 1; numExplod
{
if abs(explodVar($t, 0, vel y)) > 2.5
 {
 modifyExplod{ID:$t;angle:explodVar($t, 0, angle)+(3*sign(603-explodVar($t, 0, anim)));}
 }
 
 if explodVar($t, 0, pos y)+explodVar($t, 0, vel y) >= 0 
 && explodVar($t, 0, vel y) > 0.2
  {
    modifyExplod{ID:$t;Vel: explodVar($t, 0, vel x)*0.8,explodVar($t, 0, vel y)*-0.5;}
  }
}
}

#For the "slowdown" effect
if Map(BrokenObject) = 1 && 
Map(SlowDownTime) > 0 
{
 pause{time:1}
 Map(SlowDownTime):=Map(SlowDownTime)-1;
}

#Resetting the objects on load,
#but condition it to ResetBG!
if roundState = 0 
&& stageVar(StageInfo.ResetBG) = 1
{
 Map(SlowDownTime):= StageConst(SlowDown);

 Map(BrokenObject):= 0;
    #We check the proper side, and use stageBGVar to see if it was broken!
 if pos x < 0 && stageBGVar(101,0,actionno) != 0 {
    #We shrink the stage via modifyStageVar
    modifyStageVar{camera.boundleft:-30;}
    #We show the reflection from the pillars via modifyBGCtrl and a BGCtrl "Enable"
    modifyBGCtrl{ID:301;value:1;}
    #We show the pillars themselves via modifyStageBG and Changeanim = 0
    modifyStageBG{ID:101;actionno:0;}
   }
 
 if pos x > 0 && stageBGVar(102,0,actionno) != 0 {
   modifyStageVar{camera.boundright:30;}
   modifyBGCtrl{ID:302;value:1;}
   modifyStageBG{ID:102;actionno:0;}
   }
}
#;=========================================================================================
#Negative states
#===============================================================================
[Statedef -4]
#Attached chars will often use helpers to interact with Teams 1 and 2.

if IsHelper(1) {#let's run this only once

 #This defines the stage color pulse.
 
 if time = 0 {Map(Adding):=1;}
 
 if GameVar(superpausetime) = 0 && GameVar(pausetime) = 0 {Map(Pulsation):=Map(Pulsation) + Map(Adding);}
 if Map(Pulsation) = 180 {Map(Adding):=-1;} 
 if Map(Pulsation) = 0 {Map(Adding):=1;}
 
 Map(Intensity):=0.4;
 
 displaytoclipboard{text:"%v";params:Map(Pulsation);}
 
 BGPalFX{ID:2;time:2;add:0,-50+Map(Pulsation)*Map(Intensity),10+Map(Pulsation)*Map(Intensity)*2.2;}
 BGPalFX{ID:3;time:2;add:0,-100+Map(Pulsation)*1.8*Map(Intensity),10+Map(Pulsation)*Map(Intensity);}
 BGPalFX{ID:4;time:2;add:-50+Map(Pulsation)*Map(Intensity),-50+Map(Pulsation)*Map(Intensity),-10+Map(Pulsation)*Map(Intensity);}
  
 #Stage Fatal! If the player dies within the window and is thrown up high enough, player will go through
 #and "fall" across, then an envhsake and a sound will play.
 if roundState = 0{Map(PlayerNumberIsDead):= -1;}#Reset everything every round
 
 if roundState = 3 && #Let's see...
 (
  (player(1),decisiveRound && player(1),Win = 1) ||
  (player(2),decisiveRound && player(2),Win = 1) ||
  (player(1),teamMode = Turns && player(1),Win = 0) || 
  (player(2),teamMode = Turns && player(2),Win = 0)
 )
 && Map(PlayerNumberIsDead) < 0#once it's checked, no need to re-check
 {
 for i = 1 ; 8
  {
   if player($i),alive = 0 && player($i),vel y != 0
   && abs(player($i),pos x + cameraPos x) < 110
   && player($i),pos y < -90
   && player($i),pos y > -130
   {
    #Mark the player for the Fatal, play the sound and pause
	Map(PlayerNumberIsDead):=player($i),ID;
	playSnd{value: 0,2;abspan:1;}
	pause{time:120}	
   }
  }
  }#End check for Roundover and win conditions
  
  if Map(PlayerNumberIsDead) > 0 && roundState > 2
  #If the stage fatal is triggered,
  #hide the lifebars, send the defeated player behind most stage layers,
  #hide their reflection and shadow, and have them "fall" under the ground level,
  #and trigger an EnvShake when they landed.
  #"Landing" moment is checked via commonstates, which is a crucial thought process
  #for this kind of universal moves.
  {
    assertSpecial{flag:nobardisplay;}
	sprPriority{value:-9;layerno:-1;RedirectID:Map(PlayerNumberIsDead);}
    modifyReflection{intensity:0;RedirectId:Map(PlayerNumberIsDead);}
	modifyShadow{intensity:0;color:0,0,0;RedirectId:Map(PlayerNumberIsDead);}
	groundLevelOffset{value:900;RedirectId:Map(PlayerNumberIsDead);}
	if playerID(Map(PlayerNumberIsDead)),StateNo = 5100
	&& playerID(Map(PlayerNumberIsDead)),Time < 2
		{
		 envShake{time:30;freq:90;ampl:10;}				
		}
  }
}#End IsHelper(1)

#Note the 'StageBackEdgeDist' and 'StageFrontEdgeDist' triggers,
#they are useful for Attached Chars!
if numHelper(1) = 0
{helper{helpertype:normal;
   facing:1;
   name:"Left_Pillar";
   pos: -stageBackEdgeDist,10;
   ID: 1;
   stateno :200;
   keyctrl : 0;
   supermovetime:0;
   pausemovetime:0;
   size.ground.back:1;
   size.ground.front:1;
   size.height:1;
   preserve:1;#This is relevant in Attached Char helpers!
   standby:0;#This is relevant in Attached Char helpers!
   immortal:1;
   ownpal:1;}
}
if numHelper(2) = 0
{helper{helpertype:normal;
   facing:-1;
   name:"Right_Pillar";
   pos: stageFrontEdgeDist,10;
   ID: 2;
   stateno :200;
   keyctrl : 0;
   supermovetime:0;
   pausemovetime:0;
   size.ground.back:1;
   size.ground.front:1;
   size.height:1;
   preserve:1;
   standby:0;
   immortal:1;
   ownpal:1;}
}  

#Now we'll define some conditions for the
#Attached Character itself, which is not used anymore.
if IsHelper = 0
{
 assertSpecial{flag:nohardcodedkeys;flag2:noautoturn;}
 tagout{}
}